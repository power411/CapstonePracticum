

#include <avr/io.h>
#include <util/delay.h>									 // for _delay_ms()
#include <avr/interrupt.h>

#define LED_BIT 0
#define LED_ON 1 << LED_BIT
#define LED_OFF 0 << LED_BIT

#define CLOCK_BIT 0
#define CLOCK_ON 1 << CLOCK_BIT
#define CLOCK_OFF 0 << CLOCK_BIT

volatile uint16_t first_edge = 0x00, second_edge = 0x00, difference = 0x00;
/*
	used to hold times from TCNT1 at which input captures occur, intialized to zero here as well as in ISR after second edge detect to determine whether
	a new code is being sent or the end of the first code
*/


int main(void)
{
	
	// initialize i/o pins
	DDRC = 0b00000111;									// initialize port C, sets pins 25,24,23 (PC2,PC1,PC0) as an output
	DDRB = 0x00;										// make sure pin 14 (PB0) is an input, as well as all pins in port B
	PORTC = 0x00;										// leave off pull-up resistors in PORTC, keeps output low
	// end initialize i/o pins
	
	// enable interrupts
	TCCR1B |= (1 << WGM13) | (1 << WGM12);							// set bits in TCCR1B so that timer is in CTC mode with ICR1 set as match value
	TIMSK1 |= (1 << ICIE1);									// enable input capture interrupts on ICP1 (pin 14)
	// end enable interrupts
	
	// turn timer on
	TCCR1B |= 0x01;										// turn timer on with no prescaling to wait for input capture
	
	sei();											// enable global interrupts

	while(1)
	{
		// wait loop
	}
	
}

ISR (TIMER1_CAPT_vect)										// ISR for pin change interrupts
{
	cli();											// temporarily disable interrupts


	if (first_edge == 0x00)									// if first edge = 0 this must be the start of a code transmission
	{
		first_edge = ICR1;								// so write value of ICR1 (which is the time at which the input occured 
												// 	to first_edge
		TCCR1B |= (1 << ICES1);								// change edge detection direction on ICP1 from low to high
		TIFR1 = (1 << ICF1);								// immediately clear interrupt generated by changing edge detect direction
												// and exit from ISR to wait for high edge
	}
	else											// if first edge not= 0 this must be the end of a code transmission
	{
		second_edge = ICR1;								// so write value of ICR1 (which is the time at which the input occured
												// 	to second_edge
		difference = first_edge - second_edge;						// determine time difference between falling and rising edges
												// 	NOTE!!!!!! - this assumes the timer has not overflowed in the time 
												//	between edges

		if ( difference == XXX)								// if difference corresponds to signal for left turn
			if ( PORTX & 0x01)							// find out if left turn is already on
				PORTX &= (0 << 0);						// if it is then  this code means turn it off
			else									// if it is not
				PORTX |= ( 1 << 0);						// light up left turn

		else if ( difference == XX)							// else if difference corresponds to signal for right turn
			if ( PORTX & 0x02)							// find out if right turn is already on
				PORTX &= (0 << 1);						// if it is then  this code means turn it off
			else									// if it is not
				PORTX |= ( 1 << 1);						// light up right turn

		else if ( difference == X)							// else if difference corresponds to signal for brake
			if ( PORTX & 0x03)							// find out if brake turn is already on
				PORTX &= (0 << 0) & (0 << 1);					// if it is then this code means turn it off
			else									// if it is not
				PORTX |= ( 1 << 0) | (1 << 1);					// light up both left and right turn

		else if ( difference == XXXX)							// else if difference corresponds to signal for brake and left turn
			if ( PORTX & 0x03)							// find out if brake and left turn is already on
				PORTX &= (0 << 0) & (0 << 1);					// if it is then this code means turn it off
			else									// if it is not
				PORTX |= ( 1 << 0) | (1 << 1);					// light up both brake and left turn

		else if ( difference == XXXXX)							// else if difference corresponds to signal for brake and right turn
			if ( PORTX & 0x03)							// find out if brake and right turn is already on
				PORTX &= (0 << 0) & (0 << 1);					// if it is then this code means turn it off
			else									// if it is not
				PORTX |= ( 1 << 0) | (1 << 1);					// light up both brake and right turn
		
		first_edge = 0x00;								// now that we have finished decoding
		second_edge = 0x00;								// reset both edge variables to 0 to wait for a new code
	}
	

	sei();											// re-enable interrupts
		
}










