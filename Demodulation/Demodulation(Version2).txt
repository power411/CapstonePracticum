/*
 * DeModulation.c
 *
 * Created: 11/13/2012 6:53:04 PM
 *  Author: jesbates
 */ 


#include <avr/io.h>
#include <util/delay.h>									 // for _delay_ms()
#include <avr/interrupt.h>

#define LED_BIT 0
#define LED_ON 1 << LED_BIT
#define LED_OFF 0 << LED_BIT

#define CLOCK_BIT 0
#define CLOCK_ON 1 << CLOCK_BIT
#define CLOCK_OFF 0 << CLOCK_BIT

volatile uint16_t first_edge = 0x0000, second_edge = 0x0000, difference = 0x0000;
/*
	used to hold times from TCNT1 at which input captures occur, intialized to zero here as well as in ISR after second edge detect to determine whether
	a new code is being sent or the end of the first code
*/


int main(void)
{
	
	// initialize i/o pins
	DDRC = 0b00000111;									// initialize port C, sets pins 25,24,23 (PC2,PC1,PC0) as an output
	DDRB = 0x00;										// make sure pin 14 (PB0) is an input, as well as all pins in port B
	PORTC = 0x00;										// leave off pull-up resistors in PORTC, keeps output low
	// end initialize i/o pins

	// enable interrupts
	PCICR = 0x01;										// enable Pin Change Interrupt 0 (on Port B)
	PCMSK0 = 0x01;										// enable interrupts on pin 14 (PB0)
	// end enable interrupts
	
	
	sei();											// enable global interrupts

	while(1)
	{
		// wait loop
	}
	
}


ISR (PCINT0_vect)
{
	// enable interrupts
	TCCR1B |= (1 << WGM13) | (1 << WGM12);				// set bits in TCCR1B so that timer is in CTC mode with ICR1 set as match value
	TIMSK1 |= (1 << ICIE1);								// enable input capture interrupts on ICP1 (pin 14)
	TCCR1B |= (0 << ICES1);								// set edge detection direction on ICP1 to detect falling edge
	TIFR1 = (1 << ICF1);								// immediately clear interrupt generated by changing edge detect direction
	// end enable interrupts
	
	PCICR = 0x00;										// disable pin change interrupts for signal decoding
	PCMSK0 = 0x00;

	// turn timer on
	TCCR1B |= 0x01;										// turn timer on with no pre-scaling to wait for input capture
}


ISR (TIMER1_CAPT_vect)									// ISR for pin change interrupts
{
	
	cli();												// temporarily disable interrupts

	if (first_edge == 0x00)								// if first edge = 0 this must be the start of a code transmission
	{
		first_edge = ICR1;								// so write value of ICR1 (which is the time at which the input occurred 
														// 	to first_edge
		TCCR1B |= (1 << ICES1);							// change edge detection direction on ICP1 from low to high
		TIFR1 = (1 << ICF1);							// immediately clear interrupt generated by changing edge detect direction												// and exit from ISR to wait for high edge
	}
	else												// if first edge not= 0 this must be the end of a code transmission
	{
		TCCR1B = (0 << 1);								// turn timer off with no pre-scaling to wait for input capture
		second_edge = ICR1;								// so write value of ICR1 (which is the time at which the input occurred
														// 	to second_edge
		difference = first_edge - second_edge;			// determine time difference between falling and rising edges
														// 	NOTE!!!!!! - this assumes the timer has not overflowed in the time 
														//	between edges

		if ( difference >= 250)							// if difference corresponds to signal for left turn (should be 510 clock cycles)
														// Marc says "Use greater than or equal to!"
		{
			if (PORTC & 0x01)							// find out if left turn is already on
			{
				PORTC = (0 << 0);						// if it is then  this code means turn it off
			}				
			else										// if it is not
			{
				PORTC = (1 << 0);						// light up left turn
			}				
		}			

		else //if ( difference <= 1200)					// else if difference corresponds to signal for right turn (should be 1020 clock cycles)
		{
			if (PORTC & 0x02)							// find out if right turn is already on
			{
				PORTC = (0 << 1);						// if it is then  this code means turn it off	
			}	
			else										// if it is not
			{
				PORTC = (1 << 1);						// light up right turn
			}				
		}
				
		first_edge = 0x0000;							// now that we have finished decoding
		second_edge = 0x0000;							// reset both edge variables to 0 to wait for a new code
		difference = 0x0000;							// reset difference as well
		TIMSK1 = (0 << ICIE1);							// disable input capture interrupts on ICP1 (pin 14)
		//TCCR1B |= (0 << ICES1);						// change edge detection direction on ICP1 from high to low
		//TIFR1 = (1 << ICF1);							// immediately clear interrupt generated by changing edge detect direction
		PCICR = 0x01;									// re-enable Pin Change Interrupt 0 (on Port B)
		PCMSK0 = 0x01;									// re-enable interrupts on pin 14
	}
	
	sei();												// re-enable interrupts
		
}
