/*
 * ModulationWithCarrierAndInterrupts.c
 *
 * Created: 11/10/2012 10:20:42 PM
 *  Author: jesbates
 */ 



//#ifndef F_CPU							//burn fuses to set clock frequency
//#define F_CPU 16000000UL				// or whatever may be your frequency
//#endif
// remember to put it before delay.h

/*
from long version data sheet page 27 - in reference to previous 4 lines of commented out code

8.2.1 Default Clock Source
The device is shipped with internal RC oscillator at 8.0MHz and with the fuse CKDIV8 programmed,
resulting in 1.0MHz system clock. The startup time is set to maximum and time-out
period enabled. (CKSEL = "0010", SUT = "10", CKDIV8 = "0"). The default setting ensures that
all users can make their desired clock source setting using any available programming interface.

*/



#include <avr/io.h>
#include <util/delay.h>									 // for _delay_ms()
#include <avr/interrupt.h>

volatile uint8_t portchistory = 0x00;					// used to determine which pin caused pin change interrupt
volatile uint8_t pulse_count = 0x00;					// used to ensure no more than two pulses are sent

#define LED_BIT 0
#define LED_ON 1 << LED_BIT
#define LED_OFF 0xFE

#define CLOCK_BIT 0
#define CLOCK_ON 1 << CLOCK_BIT
#define CLOCK_OFF 0xFE

int main(void)
{
	
	// initialize i/o pins
	DDRC = 0b00000001;								// initialize port C, sets pin 23 (PC0) as an output
	PORTC = 0x00;									// leave off pull-up resistors in PORTC, sets output high
	// end initialize i/o pins
	
	// enable interrupts
	PCICR = 0x02;									// enable Pin Change Interrupt 1
	PCMSK1 = 0x18;									// enable interrupts on pin 27 (PC4) and pin 26 (PC3)
	// end enable interrupts
	
	// prepare the timer for modulation but dont turn it on
	OCR2A = 102;									// Output Compare A (for Timer2) set at 102 clock cycles (78KHz would be 12.8 nanosec)
	TCCR2A |= (1 << WGM21);							// set timer2 ("modulator" timer) to CTC mode
	TIMSK2 |= (1 << OCIE2A);						// allows interrupts on compare match
	TCCR2B &= CLOCK_OFF;								// make sure timer is not started
	// end prepare of timer for modulation
	
	// prepare timer for "carrier" but dont turn it on
	// Output Compare A (for Timer1) set at in pin change interrupt depending on which pin cause interrupt
	TCCR1B |= (1 << WGM12);							// set timer1 ("carrier" timer) to CTC mode
	TIMSK1 |= (1 << OCIE1A);						// allows interrupts on compare match
	TCCR1B &= CLOCK_OFF;								// make sure timer is not started
	// end prepare timer for modulation
	
	sei();											// enable interrupts
	
	while(1)
	{
		
		// wait loop
	}
	
}

ISR (PCINT1_vect)									// ISR for pin change interrupts
{
	uint8_t pin;									// used to determine which pin caused interrupt
	
	pin = PINC ^ portchistory;						// XOR current values on PORTC I/O pins with PORTC values from last interrupt
													//		to determine if a new interrupt has been generated by a different pin
													//		from last interrupt
	portchistory = PINC;							// write new PORTC pin values in to portchistory to determine if a new pin causes
													//		next interrupt
	

	if (pin & ( 1 << PINC4))
	{
		OCR1A = 8160;								// Output Compare A (for Timer1) set at 8160 clock cycles (this is 40 periods of the 39KHz carrier)
		TCCR1B |= CLOCK_ON;							// start timer 1 ("modulator" timer)
		TCCR2B |= CLOCK_ON;							// start timer 2 ("carrier" timer)
	}
	else if (pin & ( 1 << PINC3))
	{
		OCR1A = 4080;								// Output Compare A (for Timer1) set at 4080 clock cycles (this is 20 periods of the 39KHz carrier)
		TCCR1B |= CLOCK_ON;							// start timer 1 ("modulator" timer)
		TCCR2B |= CLOCK_ON;							// start timer 2 ("carrier" timer)
	}
	else											// if timer is currently on, this must be turn signal has been de-activated
	{
		TCCR2B &= CLOCK_OFF;							// stop timer 2 ("carrier" timer)
		TCCR1B &= CLOCK_OFF;							// also stop timer 1 ("modulator" timer) because signal is no longer active
		PORTC &= LED_OFF;							// make sure output is off
	}

}

ISR (TIMER2_COMPA_vect)								// ISR for timer compare match interrupts
{
	
	if (PORTC & 0x01)								// if output pin (which controls transmitter) is high
		PORTC &= LED_OFF;							// Low on pin 23
	else
		PORTC |= LED_ON;							// High on pin 23
}
/*
	timer 2 is the carrier timer, its compare value (set by OCR2A) is set so that an interrupt is generated every
	***HALF*** period of a 39KHz wave.  on each interrupt the output voltage on pin 23 is toggled between high and low.
	this will generate a 39KHz carrier wave on the IR transmitting device
*/

ISR (TIMER1_COMPA_vect)
{
	cli();											// disable interrupts for use of temp register (T/C 1 is 16 bit)
	
	if (TCCR2B & 0x01)								// if timer 2 ("carrier" timer) is currently active
	{
		if (pulse_count == 0x00)					// if the first pulse of the modulator timer has been sent
		{
			pulse_count = 0x01;						// update pulse count and send another pulse
		}			
		else
		{
			TCCR2B &= CLOCK_OFF;						// stop timer 2 ("carrier" timer)
			PORTC &= LED_OFF;						// make sure PORTC0 (pin 23) is low
			TCCR1B &= CLOCK_OFF;						// turn TC1 off so that there is only 1 burst of 39KHz
			pulse_count = 0x00;						// reset pulse count so that next interrupt generates two pulses
		}
	}		
	else
		TCCR2B |= CLOCK_ON;							// if timer 2 ("carrier" timer) is NOT currently on then turn it on
	sei();											// reenable interrupts
}
/*
	timer 1 is the modulator timer, its compare value is set in this example in the pin change interrupt routine.
	depending on which pin causes the interrupt the compare value is set to either x or y which toggles the carrier
	timer on for x/y cycles and then off for x/y cycles
*/