/*
 * ModulationWithCarrier.c
 *
 * Created: 11/10/2012 7:47:48 PM
 *  Author: jesbates
 */ 



//#ifndef F_CPU							//burn fuses to set clock frequency
//#define F_CPU 16000000UL				// or whatever may be your frequency
//#endif
// remember to put it before delay.h

/*
from long version data sheet page 27 - in reference to previous 4 lines of commented out code

8.2.1 Default Clock Source
The device is shipped with internal RC oscillator at 8.0MHz and with the fuse CKDIV8 programmed,
resulting in 1.0MHz system clock. The startup time is set to maximum and time-out
period enabled. (CKSEL = "0010", SUT = "10", CKDIV8 = "0"). The default setting ensures that
all users can make their desired clock source setting using any available programming interface.

*/



#include <avr/io.h>
#include <util/delay.h>									 // for _delay_ms()
#include <avr/interrupt.h>

volatile uint8_t portchistory = 0x00;					// used to determine which pin caused pin change interrupt

#define LED_BIT 0
#define LED_ON 1 << LED_BIT
#define LED_OFF 0 << LED_BIT

#define CLOCK_BIT 0
#define CLOCK_ON 1 << CLOCK_BIT
#define CLOCK_OFF 0 << CLOCK_BIT

int main(void)
{
	
	// initialize i/o pins
	DDRC = 0b00000001;								// initialize port C, sets pin 23 (PC0) as an output
	PORTC = 0x00;									// leave off pull-up resistors in PORTC, sets output high
	// end initialize i/o pins
	
	// enable interrupts
	PCICR = 0x02;									// enable Pin Change Interrupt 1
	PCMSK1 = 0x10;									// enable interrupts on pin 27 (PC4)
	// end enable interrupts
	
	// prepare the timer for modulation but dont turn it on
	OCR2A = 102;									// Output Compare A (for Timer2) set at 102 clock cycles (78KHz would be 12.8 nanosec)
	TCCR2A |= (1 << WGM21);							// set timer2 ("modulator" timer) to CTC mode
	TIMSK2 |= (1 << OCIE2A);						// allows interrupts on compare match
	TCCR2B = CLOCK_OFF;								// make sure timer is not started
	// end prepare of timer for modulation
	
	// prepare timer for "carrier" but dont turn it on
	OCR1A = 40800;									// Output Compare A (for Timer1) set at 40800 clock cycles (this is 200 periods of the 39KHz carrier)
	TCCR1B |= (1 << WGM12);							// set timer1 ("carrier" timer) to CTC mode
	TIMSK1 |= (1 << OCIE1A);						// allows interrupts on compare match
	TCCR1B = CLOCK_OFF;								// make sure timer is not started
	// end prepare timer for modulation
	
	sei();											// enable interrupts
	
	while(1)
	{
		
		// wait loop
	}
	
}

ISR (PCINT1_vect)									// ISR for pin change interrupts
{
	uint8_t pin;									// used to determine which pin caused interrupt
	
	pin = PINC ^ portchistory;						// XOR current values on PORTC I/O pins with PORTC values from last interrupt
													//		to determine if a new interrupt has been generated by a different pin
													//		from last interrupt
	portchistory = PINC;							// write new PORTC pin values in to portchistory to determine if a new pin causes
													//		next interrupt
	
	
	
	if (pin & ( 1 << PINC4))
	{
		TCCR1B |= CLOCK_ON;							// start timer 1 ("modulator" timer)
		TCCR2B |= CLOCK_ON;							// start timer 2 ("carrier" timer)
	}
	else											// if timer is currently on, this must be turn signal has been de-activated
	{
		TCCR2B = CLOCK_OFF;							// stop timer 2 ("carrier" timer)
		TCCR1B = CLOCK_OFF;							// also stop timer 1 ("modulator" timer) because signal is no longer active
		PORTC = LED_OFF;							// make sure output is off
	}

}

ISR (TIMER2_COMPA_vect)								// ISR for timer compare match interrupts
{
	
	if (PORTC & 0x01)								// if output pin (which controls transmitter) is high
		PORTC = LED_OFF;							// Low on pin 23
	else
		PORTC |= LED_ON;							// High on pin 23
}
/*
	timer 2 is the carrier timer, its compare value (set by OCR2A) is set so that an interrupt is generated every
	***HALF*** period of a 39KHz wave.  on each interrupt the output voltage on pin 23 is toggled between high and low.
	this will generate a 39KHz carrier wave on the IR transmitting device
*/

ISR (TIMER1_COMPA_vect)
{
	if (TCCR2B & 0x01)								// if timer 2 ("carrier" timer) is currently active
	{
		TCCR2B = CLOCK_OFF;							// stop timer 2 ("carrier" timer)
		PORTC = LED_OFF;							// make sure PORTC0 (pin 23) is low
	}		
	else
		TCCR2B |= CLOCK_ON;							// if timer 2 ("carrier" timer) is NOT currently on then turn it on
}
/*
	timer 1 is the modulator timer, its compare value is set in this example so that an interrupt is generated every 200 cycles of 
	the carrier wave. this will toggle the carrier timer on for 200 cycles and then off for 200 cycles
*/